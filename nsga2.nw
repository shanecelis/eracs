\section{NSGA-II}

We want to use an NSGA-II search algorithm with Guile Scheme. A C
library exists; we're just going to wrap it.  We're also going to make
the following assumptions: real valued genes only, no constraints.  

<<file:nsga2.c>>=
#include <stdio.h>
#include <libguile.h>
#include "global.h"
#include "rand.h"
#include "logging.h"
#include "util.h"

<<Macro>>

<<State>>

<<Helper Function>>

<<C Fitness Function>>

<<Primitive Procedure>>

void init_nsga2()
{
  scm_c_define_gsubr("primitive-nsga-ii-search", 
                     9, 0, 0, 
                     primitive_nsga_ii_search); 
}
@

Rather than deal with all the default values in the primitive
procedure, which would be cumbersome, we'll deal with that in the
Scheme code, which is a lot easier.

<<Procedure>>= 
(define*-public (nsga-ii-search fitness-function #:key
                                (objective-count 1)
                                (gene-count 1)
                                (population-count 4)
                                (generation-count 1)
                                (random-seed #f)
                                (seed-individual #f)
                                (seed-population #f)
                                (generation-tick-func #f))
  (primitive-nsga-ii-search fitness-function 
                            objective-count 
                            gene-count 
                            population-count
                            generation-count
                            random-seed
                            seed-individual
                            seed-population
                            generation-tick-func))
@ 

<<test>>=
(check-true nsga-ii-search)
@ 

Let's try to maximize our genes.

<<test>>=
(let ((result  (car (nsga-ii-search (lambda (x) (vector-map - x)) 
                                #:random-seed 0.1 #:generation-count 100))))
  (check (car result) (=> vector=?) #(1.0)) ;; genome
  (check (cdr result) (=> vector=?) #(-1.0))) ;; fitness
@ 

Let's try to minimize our genes.

<<test>>=
(let ((result  (car (nsga-ii-search (lambda (x) x) 
                                #:random-seed 0.1 #:generation-count 100))))
  (check (car result) (=> vector=?) #(-1.0)) ;; genome
  (check (cdr result) (=> vector=?) #(-1.0))) ;; fitness

@ 

Let's minimize for $x^2$.

<<test>>=
(let ((result  (car (nsga-ii-search (lambda (x) (vector-map * x x)) 
                                #:random-seed 0.1 #:generation-count 100))))
  (check (car result) (=> vector=?) #(0.0))
  (check (cdr result) (=> vector=?) #(0.0)))
@ 


The primitive procedure has no optional arguments.  The code is
derived from the NSGA-II code in [[nsga2r.c]].

<<Primitive Procedure>>=
SCM primitive_nsga_ii_search(
  SCM fitness_function,
  SCM objective_count,
  SCM gene_count,
  SCM population_count,
  SCM generation_count,
  SCM random_seed,
  SCM seed_individual,
  SCM seed_population,
  SCM generation_tick_func
)
{
  int i;
  population *parent_pop;
  population *child_pop;
  population *mixed_pop;

  <<Setup search parameters.>>
  fitness_procedure = fitness_function;
  bitlength = 0;
  nbinmut = 0;
  nrealmut = 0;
  nbincross = 0;
  nrealcross = 0;

  parent_pop = (population *)malloc(sizeof(population));
  child_pop  = (population *)malloc(sizeof(population));
  mixed_pop  = (population *)malloc(sizeof(population));
  allocate_memory_pop (parent_pop, popsize);
  allocate_memory_pop (child_pop, popsize);
  allocate_memory_pop (mixed_pop, 2*popsize);
  randomize();
  initialize_pop (parent_pop);
  <<Insert seed individual if available.>>
  <<Insert seed population if available.>>
  i = 1;
  mylog("nsga2", PRI_TRACE, "start of generation %d", 1);     
  decode_pop (parent_pop);
  evaluate_pop (parent_pop);
  assign_rank_and_crowding_distance (parent_pop);
  SCM continue_p = SCM_BOOL_T;
  <<Call generation tick.>>
  if (scm_is_false(continue_p))
    goto no_loop;
  for (i = 2; i <= ngen; i++) {
    selection (parent_pop, child_pop);
    mylog("nsga2", PRI_TRACE, "start of generation %d", i);
    mutation_pop (child_pop);
    decode_pop(child_pop);
    evaluate_pop(child_pop);
    merge (parent_pop, child_pop, mixed_pop);
    fill_nondominated_sort (mixed_pop, parent_pop);
    /* Comment following four lines if information for all
       generations is not desired, it will speed up the execution */
    <<Call generation tick.>>
    if (scm_is_false(continue_p))
      break;
    //report_pop(parent_pop,fpt4);
    //fflush(fpt4);
    //printf("\n gen = %d",i);
    scm_gc();
  }

no_loop:
  ; /* workaround for Guile bug, I believe. */
  SCM results = scm_report_feasible(parent_pop);
  if (nreal!=0) {
    free (min_realvar);
    free (max_realvar);
  }
  deallocate_memory_pop (parent_pop, popsize);
  deallocate_memory_pop (child_pop, popsize);
  deallocate_memory_pop (mixed_pop, 2*popsize);
  free (parent_pop);
  free (child_pop);
  free (mixed_pop);
  return results;
}
@ 

<<Call generation tick.>>=
if (! scm_is_false(generation_tick_func)) {
  continue_p = scm_call_2(generation_tick_func, scm_from_int(i), scm_report(parent_pop));
}
@ 

<<Insert seed individual if available.>>=
if (! scm_is_false(seed_individual)) {
  mylog("nsga2", PRI_DEBUG, "setting seed individual");
  int i;
  individual *ind = &(parent_pop->ind[0]);
  for (i = 0; i < nreal; i++)
      ind->xreal[i] = scm_to_double(scm_c_vector_ref(seed_individual, i));
}
@


<<Insert seed population if available.>>=
if (! scm_is_false(seed_population)) {
  mylog("nsga2", PRI_DEBUG, "setting seed population of %d individuals", scm_c_length(seed_population));
  int j, seed_individual_count;
  SCM list;
  for (j = 0,         list = seed_population;
       j < popsize && scm_is_pair(list);
       j++,           list = scm_cdr(list)) {
    individual *ind = &(parent_pop->ind[0]);
    SCM src = scm_car(seed_population);

#define GET_READ_DOUBLE_HANDLE(scm_var, double_array) \
  scm_t_array_handle scm_var ## _handle; \
  scm_array_get_handle(scm_var, &scm_var ## _handle); \
  const double* double_array = scm_array_handle_f64_elements(&scm_var ## _handle);

#define RELEASE_HANDLE(scm_var) \
  scm_array_handle_release(&scm_var ## _handle);

  GET_READ_DOUBLE_HANDLE(src, src_array);

  

  memcpy(ind->xreal, src_array, nreal * sizeof(double));                                
  RELEASE_HANDLE(src);

//   for (int i = 0; i < nreal; i++)
//      ind->xreal[i] = scm_to_double(scm_c_vector_ref(src, i));
  }
  if (scm_is_pair(list))
    mylog("nsga2", PRI_WARN, "seed population %d larger than population size %d", scm_c_length(seed_population), popsize);
}
@

The fitness function calls our Scheme function.  (This function should
really be a function pointer and include a [[void* context]], but
that's not in my control.)  One concern is, while this is operating,
do I need to deal with garbage collection manually?

<<C Fitness Function>>=
void test_problem (double *xreal, 
                   double *xbin, 
                   int **gene, 
                   double *obj, 
                   double *constr)
{
  SCM genome, objectives;
  genome = scm_c_array_to_vector(nreal, xreal);
  objectives = scm_call_1(fitness_procedure, genome);
  scm_c_vector_to_array(objectives, nobj, obj);
}
@ 

<<Helper Function>>=
SCM scm_c_array_to_vector(int count, double* array) 
{
  int i;
  SCM v = scm_c_make_vector(count, SCM_UNSPECIFIED);
  for (i = 0; i < count; i++) 
    scm_c_vector_set_x(v, i, scm_from_double(array[i]));
  return v;
}
@ 

<<Macro>>=
#define C_STRING_TO_SYMBOL(str) scm_string_to_symbol(scm_from_locale_string(str))
@ 


<<Helper Function>>=
SCM scm_c_array_to_f64_vector(int count, double* array) 
{
  int i;
  SCM v = scm_make_typed_array(C_STRING_TO_SYMBOL("f64"), SCM_UNSPECIFIED, scm_list_1(scm_from_int(count)));
  for (i = 0; i < count; i++) 
    scm_array_set_x(v, scm_from_double(array[i]), scm_list_1(scm_from_int(i)));
  return v;
}
@ 


<<Helper Function>>=
void scm_c_vector_to_array(SCM v, int count, double* array) 
{
  int i;
  for (i = 0; i < count; i++) 
    array[i] = scm_to_double(scm_c_vector_ref(v, i));
}
@ 


<<State>>=
SCM fitness_procedure;
@ 

<<Setup search parameters.>>=
  if (scm_is_false(random_seed)) 
    seed = scm_to_double(scm_random(scm_from_double(1.0), 
                                    scm_random_state_from_platform()));
  else
    seed = scm_to_double(random_seed);
  if (seed <= 0.0 || seed >= 1.0) {
    // XXX Should throw an exception.
    return SCM_BOOL_F;
  }
  popsize = scm_to_int(population_count);
  if (popsize%4 != 0) {
  
    mylog("nsga2", PRI_WARN, "adjusting population size from %d to %d", popsize, popsize += 4 - popsize%4);
    //scm_throw(scm_c_string_to_symbol("invalid-population-size"), SCM_EOL);
  }
  ngen = scm_to_int(generation_count);
  nobj = scm_to_int(objective_count);
  ncon = 0; // Zero constraints.
  nreal = scm_to_int(gene_count);
  min_realvar = (double *)malloc(nreal*sizeof(double));
  max_realvar = (double *)malloc(nreal*sizeof(double));
  // Default range of real values is [-1, 1].
  for (i=0; i<nreal; i++) {
    min_realvar[i] = -1.0;
    //printf("min %e\n", min_realvar[i]);
    max_realvar[i] = 1.0;
  }
  pcross_real = 0.6;
  pmut_real = 1.0/((double)nreal);
  // I don't know what these values actually mean.
  // XXX Find out!
  eta_c = 5;
  eta_m = 5;
  nbin = 0;
  choice = 0;
@ 

These are expected variables defined in [[global.h]].

<<State>>=
int nreal;
int nbin;
int nobj;
int ncon;
int popsize;
double pcross_real;
double pcross_bin;
double pmut_real;
double pmut_bin;
double eta_c;
double eta_m;
int ngen;
int nbinmut;
int nrealmut;
int nbincross;
int nrealcross;
int *nbits;
double *min_realvar;
double *max_realvar;
double *min_binvar;
double *max_binvar;
int bitlength;
int choice;
int obj1;
int obj2;
int obj3;
int angle1;
int angle2;
@ 

We want to collect some information from the last population to report
back from this search.  This is modeled after the [[report-feasible]]
in the NSGA-II C code [[report.c]].

<<Helper Function>>=
SCM scm_report_feasible(population *pop)
{
  SCM list = SCM_EOL;
  int i, j, k;
  for (i = 0; i < popsize; i++) {
    if (//pop->ind[i].constr_violation == 0.0 
        //&& 
        pop->ind[i].rank == 1) {
      SCM objective;
      SCM genome;
      // XXX Switch these to uniform vectors
      objective = scm_c_array_to_vector(nobj,  pop->ind[i].obj);
      genome    = scm_c_array_to_f64_vector(nreal, pop->ind[i].xreal);
      // Add it to the list.
      list = scm_cons(scm_cons(genome, objective), list);
    }
  }
  return list;
}
@ 

<<Helper Function>>=
SCM scm_report(population *pop)
{
  SCM list = SCM_EOL;
  int i, j, k;
  for (i = 0; i < popsize; i++) {
    if (1
      //pop->ind[i].constr_violation == 0.0 
    //&& pop->ind[i].rank == 1
    ) {
      SCM objective;
      SCM genome;
      // XXX Switch these to uniform vectors
      objective = scm_c_array_to_vector(nobj,  pop->ind[i].obj);
      genome    = scm_c_array_to_f64_vector(nreal, pop->ind[i].xreal);
      // Add it to the list.
      list = scm_cons(scm_list_3(scm_from_int(pop->ind[i].rank), genome, objective), list);
    }
  }
  return list;
}
@ 


Let's write a module file that'll automatically load this shared
library.
<<file:nsga2.scm>>=
(define-module (nsga2)
 #:use-module (ice-9 optargs))

(load-extension "./libguile-nsga2.dylib" "init_nsga2")
<<Procedure>>

(export nsga-ii-search)
@ 

<<file:nsga2.test.scm>>=
;; nsga2-test.scm
(use-modules (nsga2)
             (vector-math))
(use-modules ((rnrs) #:select (vector-map vector-for-each mod)))
<<+ Test Preamble>>
<<test>>
<<+ Test Postscript>>
@
