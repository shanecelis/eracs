\subsection{Rigid Body SMOB}

SMOBs are simple objects that GNU Guile uses to wrap \verb|C/C++|
objects into something that is Scheme friendly.  SMOBs are garbage
collected.  We'll define two types of SMOBs: rigid body, and
constraint (or joint).  

<<file:rigid-body-smob.h>>=

#ifndef SCM_MAGIC_SNARFER
#include <btBulletDynamicsCommon.h>
#endif
#include <libguile.h>

struct rigid_body {
  btRigidBody *body;
  btCollisionShape *shape;
  btDynamicsWorld *world;
  SCM name;
  SCM contact_func;
};

SCM wrap_rigid_body(btRigidBody* rb, char *name, SCM contact_func);

void call_contact_func(SCM smob);
void init_rigid_body_type(void);
@ %def rigid_body
<<file:rigid-body-smob.cpp>>=

<<+ Preamble>>

<<Includes>>

<<State>>

<<Helper Functions>>

/* SMOB functions */
<<Free>>
<<Mark>>
<<Print>>
@ All SMOBs must implement three functions: \verb|free|, \verb|mark| ,
and \verb|print|.

<<Free>>=

static size_t free_rigid_body (SCM rigid_body_smob)
{
  struct rigid_body *rigid_body = (struct rigid_body *) SCM_SMOB_DATA (rigid_body_smob);
  if (rigid_body->body) {
    if (rigid_body->world)
      rigid_body->world->removeRigidBody(rigid_body->body);    
    delete rigid_body->body;
  }
  scm_gc_free (rigid_body, sizeof (struct rigid_body), "rigid_body");
  return 0;
}
@ We want to mark all the living objects so that they will not be
garbage collected.  This will be called often for objects that are
live.

<<Mark>>=

static SCM mark_rigid_body (SCM rigid_body_smob)
{
  //fprintf(stderr, "mark_rigid_body\n");
  /* Mark the rigid_body's name and update function.  */
  struct rigid_body *rigid_body = (struct rigid_body *) SCM_SMOB_DATA (rigid_body_smob);
     
  scm_gc_mark (rigid_body->name);
  return (rigid_body->contact_func); // will recurse and mark these
     
  //return SCM_BOOL_F;
}
@ When the smob is printed to string, say on the REPL, it will use
whatever this function produces.  The convention for non-readable
objects is to format it as \verb|#<smob-name other details...>#|.

<<Print>>=

static int print_rigid_body (SCM rigid_body_smob, SCM port, scm_print_state *pstate)
{
  struct rigid_body *rigid_body = (struct rigid_body *) SCM_SMOB_DATA (rigid_body_smob);
     
  scm_puts ("#<rigid_body ", port);
  scm_display (rigid_body->name, port);
  scm_puts (">", port);
     
  /* Non-zero means success. */
  return 1;
}
@ Let's register this new SMOB type and its associated functions with
Guile.  That requires we keep a ``tag'' to identify our SMOB from
others.

<<State>>=

static scm_t_bits rigid_body_tag;
<<Initialize.>>=

void init_rigid_body_type(void)
{
#ifndef SCM_MAGIC_SNARFER 
#include "rigid-body-smob.cpp.x" 
#endif
  rigid_body_tag = scm_make_smob_type ("rigid-body", sizeof (struct rigid_body));
  scm_set_smob_mark (rigid_body_tag, mark_rigid_body);
  scm_set_smob_free (rigid_body_tag, free_rigid_body);
  scm_set_smob_print (rigid_body_tag, print_rigid_body);
  <<Register contact handler.>>

}
@ The \verb|wrap_rigid_body| procedure which will return a SMOB, which
is an \verb|SCM| type.  This will allow one to export a C object to
Scheme.

<<file:rigid-body-smob.cpp>>=


SCM wrap_rigid_body(btRigidBody* btrb, char* name, SCM contact_func)
{
  SCM smob;
  static int rigid_body_count = 0;
  struct rigid_body *rb;
     
  /* Step 1: Allocate the memory block.
   */
  rb = (struct rigid_body *)
    scm_gc_malloc (sizeof (struct rigid_body), "rigid-body");
     
  /* Step 2: Initialize it with straight code.
   */
  rb->body = btrb;
  rb->world = NULL;
  //rb->body->forceActivationState(DISABLE_DEACTIVATION);
  if (name)
    rb->name = scm_from_locale_string(name);
  else {
    char body_name[80];
    sprintf(body_name, "body-%d", rigid_body_count);
    rb->name = scm_from_locale_string(body_name);
  }
  rigid_body_count++;
  if (SCM_UNBNDP(contact_func)) {
    rb->contact_func = SCM_BOOL_F;
  } else {
    rb->contact_func = contact_func;
  }
  /* Step 3: Create the smob.
   */
  SCM_NEWSMOB (smob, rigid_body_tag, rb);
  rb->body->setUserPointer(smob);

     
  /* Step 4: Finish the initialization.
   */
  //image->name = name;
  // image->pixels =
  //   scm_gc_malloc (width * height, "image pixels");
     
  return smob;  
}
@ Now let's allow ourselves to create this C object from Scheme.

<<file:rigid-body-smob.cpp>>=

// XXX Rename this to make-box or include a parameter for shape.
SCM_DEFINE (make_box, "make-box", 2, 3, 0,
            (SCM pos, SCM dims, SCM mass, SCM name, SCM contact_func),
            "Make a rigid body.")
{
  btTransform transform;
  btDefaultMotionState* motionState;
  btBoxShape *shape;
  btVector3 local_inertia(0.,0.,0.);
  btRigidBody *body;

  transform.setIdentity(); 
  transform.setOrigin(vector_to_btVector3(pos));
  motionState = new btDefaultMotionState(transform);
  shape = new btBoxShape(0.5 * vector_to_btVector3(dims));
  shape->calculateLocalInertia(SCM_UNBNDP(mass) 
                               ? 1. : scm_to_double(mass), 
                               local_inertia);
  //shape->setUserPointer(&IDs[index]);
  //shape->initializePolyhedralFeatures();
  btRigidBody::btRigidBodyConstructionInfo 
    con_info(SCM_UNBNDP(mass) ? 1. : scm_to_double(mass),
          motionState, shape, local_inertia);

  body = new btRigidBody(con_info);

  return wrap_rigid_body(body, 
                         SCM_UNBNDP(name) 
                         ? NULL 
                         : scm_to_locale_string(name), 
                         contact_func);
}
@ Initialize the rigid body SMOB when the application starts.

<<+ Include submodules.>>=

#include "rigid-body-smob.h"
<<+ Initialize submodules.>>=

init_rigid_body_type();
@ One can create a rigid body, but it doesn't do anything by itself.
How does one add it to a physics simulation?  Let's write that next.

<<Add rigid body to simulation.>>=

SCM_DEFINE (scm_sim_add_body, 
            "sim-add-body", 
            2, 0, 0,
            (SCM sim, SCM body),
            "Add rigid body to simulation.")
{
  struct sim *s = unwrap_sim(sim);

  scm_assert_smob_type(rigid_body_tag, body);
  struct rigid_body *rb = (struct rigid_body*) SCM_SMOB_DATA(body);
  s->world->addRigidBody(rb->body);
  rb->world = s->world;
  return SCM_BOOL_T;
}
<<Remove rigid body from simulation.>>=

SCM_DEFINE (scm_sim_remove_body, 
            "sim-remove-body", 
            2, 0, 0,
            (SCM sim, SCM body),
            "Remove rigid body from simulation.")
{
  struct sim *s = unwrap_sim(sim);
  scm_assert_smob_type(rigid_body_tag, body);
  struct rigid_body *rb = (struct rigid_body*) SCM_SMOB_DATA(body);
  if (s->world) {
    s->world->removeRigidBody(rb->body);
    rb->body->getCollisionShape()->setUserPointer(NULL);
    
    rb->world = NULL;
    return SCM_BOOL_T;
  } else
    return SCM_BOOL_F;
}
<<file:rigid-body-smob.cpp>>=

<<Add rigid body to simulation.>>
<<Remove rigid body from simulation.>>
<<Helper Functions>>=

btVector3 vector_to_btVector3(SCM vector) {
  btVector3 rgb;
  for (int i = 0; i < 3; i++)
    rgb[i] = scm_to_double(scm_vector_ref(vector, scm_from_int(i)));
  if (scm_c_vector_length(vector) == 4)
    rgb[3] = scm_to_double(scm_vector_ref(vector, scm_from_int(3)));
  return rgb;
}
<<Includes>>=

#ifndef SCM_MAGIC_SNARFER
/* Headers we don't want snarfed. */
#include "btBulletDynamicsCommon.h"
#include "physics.h"
#endif
/* Headers we must have snarfed. */
#include <libguile.h>
#include "rigid-body-smob.h"
#include "sim-smob.h"
@ \subsection{Getting Center of Mass}

<<file:rigid-body-smob.cpp>>=

SCM_DEFINE (scm_get_position, 
            "get-position", 
            1, 0, 0,
            (SCM rb_smob),
            "Get position of body from simulation.")
{
  scm_assert_smob_type(rigid_body_tag, rb_smob);
  struct rigid_body *rb = (struct rigid_body*) SCM_SMOB_DATA(rb_smob);
  return btVector3_to_vector3(rb->body->getCenterOfMassPosition());
}
<<Helper Functions>>=
SCM btVector3_to_vector(btVector3 vector) {
  SCM v = scm_c_make_vector(4, SCM_UNDEFINED);
  for (int i = 0; i < 4; i++)
    scm_vector_set_x(v, scm_from_int(i), scm_from_double(vector[i]));
  return v;
}
@ 

<<Helper Functions>>=
SCM btVector3_to_vector3(btVector3 vector) {
  SCM v = scm_c_make_vector(3, SCM_UNDEFINED);
  for (int i = 0; i < 3; i++)
    scm_c_vector_set_x(v, i, scm_from_double(vector[i]));
  return v;
}
@
\subsection{Handling Collisions}

<<file:rigid-body-smob.cpp>>=

void physics_call_contact_func(SCM rigid_body_smob)
{
  if (rigid_body_smob 
      && SCM_SMOB_PREDICATE(rigid_body_tag, rigid_body_smob)) {
    scm_assert_smob_type(rigid_body_tag, rigid_body_smob);
    struct rigid_body *rb;
    rb = (struct rigid_body *) SCM_SMOB_DATA (rigid_body_smob);
    if (scm_is_true(scm_procedure_p(rb->contact_func))) {
      SCM result = scm_call_0(rb->contact_func);
    }
  }
}
<<file:rigid-body-smob.cpp>>=

bool contact_callback(btManifoldPoint& cp,
                      void* body0, void* body1)
{

  int *ID1, *ID2;
  btCollisionObject* o1 = static_cast<btCollisionObject*>(body0);
  btCollisionObject* o2 = static_cast<btCollisionObject*>(body1);

  if (o1->getUserPointer()) {
    SCM rigid_body_smob = (SCM) o1->getUserPointer();
    physics_call_contact_func(rigid_body_smob);
  }

  if (o2->getUserPointer()) {
    SCM rigid_body_smob = (SCM) o2->getUserPointer();
    physics_call_contact_func(rigid_body_smob);
  }
  return false;
}
@ Now, we have to register our \verb|contact_callback| with Bullet.
Unfortunately, this is done with a global variable rather than
attaching it to some world object.

<<Register contact handler.>>=


gContactProcessedCallback = contact_callback;
<<file:rigid-body-smob.cpp>>=

SCM_DEFINE (set_contact_func_x, 
            "set-contact-func!", 
            2, 0, 0,
            (SCM rigid_body_smob, SCM func),
            "Set the contact function for a rigid body.")
{
  struct rigid_body *rb;
  scm_assert_smob_type(rigid_body_tag, rigid_body_smob);
  rb = (struct rigid_body *) SCM_SMOB_DATA (rigid_body_smob);
  rb->contact_func = func;
  return SCM_UNSPECIFIED;
}
@ \subsection{Constraint SMOB}

In addition to rigid bodies, ERACS handles constraints, or joints, as
SMOBs.

<<file:rigid-body-smob.h>>=

struct constraint {
  btTypedConstraint* joint;
  btRigidBody *bodyA;
  btRigidBody *bodyB;
  btDynamicsWorld *world;
  SCM type;
  SCM name;
  SCM update_func;
  /* int active; */
  /* double target_angle; */
};

SCM wrap_constraint(btTypedConstraint* rb, 
                    char *name, 
                    char *type_label, 
                    btRigidBody *a, 
                    btRigidBody *b);

void init_constraint_type(void);
<<State>>=

static scm_t_bits constraint_tag;
@ The SMOB requires three functions: \verb|free|, \verb|mark|, and
\verb|print|.

<<Free>>=

static size_t free_constraint (SCM constraint_smob)
{
  struct constraint *constraint;
  constraint = (struct constraint *) SCM_SMOB_DATA (constraint_smob);
  if (constraint->joint && constraint->world) {
    constraint->world->removeConstraint(constraint->joint);    
    delete constraint->joint;
  }
  scm_gc_free (constraint, sizeof (struct constraint), "constraint");
  return 0;
}
<<Mark>>=

static SCM mark_constraint (SCM constraint_smob)
{
  //fprintf(stderr, "mark_constraint\n");
  /* Mark the constraint's name and update function.  */
  struct constraint *constraint;
  constraint = (struct constraint *) SCM_SMOB_DATA (constraint_smob);
     
  scm_gc_mark (constraint->name);
  scm_gc_mark (constraint->update_func);
  return (constraint->type); // will recurse and mark these
}
<<Print>>=

static int print_constraint (SCM constraint_smob, SCM port, scm_print_state *pstate)
{
  struct constraint *constraint;
  constraint = (struct constraint *) SCM_SMOB_DATA (constraint_smob);
     
  scm_puts ("#<constraint ", port);
  scm_display (constraint->name, port);
  scm_puts (">", port);
     
  /* Non-zero means success. */
  return 1;
}
<<Initialize.>>=

void init_constraint_type(void)
{
  constraint_tag = scm_make_smob_type ("constraint", sizeof (struct constraint));
  scm_set_smob_mark (constraint_tag, mark_constraint);
  scm_set_smob_free (constraint_tag, free_constraint);
  scm_set_smob_print (constraint_tag, print_constraint);
}
<<+ Initialize submodules.>>=

init_constraint_type();
@ Similar to \verb|wrap_rigid_body|, \verb|wrap_constraint| accepts a
pointer to a constraint and creates a SMOB, which is an \verb|SCM|
type.

<<file:rigid-body-smob.cpp>>=

SCM wrap_constraint(btTypedConstraint* bttc, 
                    char* name, char* type_label, 
                    btRigidBody *a, btRigidBody *b)
{
  static int constraint_count = 0;
  SCM smob;
  struct constraint *tc;
     
  /* Step 1: Allocate the memory block.
   */
  tc = (struct constraint *)
    scm_gc_malloc (sizeof (struct constraint), "constraint");
     
  /* Step 2: Initialize it with straight code.
   */
  tc->joint = bttc;
  tc->bodyA = a;
  tc->bodyB = b;
  tc->world = NULL;
  if (name)
    tc->name = scm_from_locale_string(name);
  else {
    char constraint_name[80];
    sprintf(constraint_name, "constraint-%d", constraint_count);
    tc->name = scm_from_locale_string(constraint_name);
  }
  constraint_count++;
  tc->type = scm_from_locale_string(type_label);
  
  /* Step 3: Create the smob. */
  SCM_NEWSMOB (smob, constraint_tag, tc);
  // No user pointer for joint objects.
  tc->joint->setUserConstraintPtr(smob);
         
  return smob;  
}
@ Let's write \verb|make-hinge| so one can create joints from Scheme.

<<file:rigid-body-smob.cpp>>=

SCM_DEFINE (make_hinge, "make-hinge", 6, 2, 0,
            (SCM body_a, SCM body_b, 
             SCM pos_a,  SCM pos_b, 
             SCM axis_a, SCM axis_b, 
             SCM name,   SCM update_func),
            "Make a hinge constraint.")
{
  struct rigid_body *rb_a, *rb_b;
  btVector3 p_a, p_b, ax_a, ax_b;

  scm_assert_smob_type(rigid_body_tag, body_a);
  rb_a = (struct rigid_body*) SCM_SMOB_DATA(body_a);
  scm_assert_smob_type(rigid_body_tag, body_b);
  rb_b = (struct rigid_body*) SCM_SMOB_DATA(body_b);
  
  p_a = vector_to_btVector3(pos_a);
  p_b = vector_to_btVector3(pos_b);
  ax_a = vector_to_btVector3(axis_a);
  ax_b = vector_to_btVector3(axis_b);

  btHingeConstraint *tc =
    new btHingeConstraint(*(rb_a->body), *(rb_b->body),
                          p_a, p_b,
                          ax_a, ax_b, false);
  /*
  if (SCM_UNBNDP(update_func)) {
    rb->update_func = SCM_BOOL_F;
  } else {
    rb->update_func = update_func;
  }*/
  /* Step 3: Create the smob.
   */
  SCM smob = wrap_constraint(tc,
                             SCM_UNBNDP(name) 
                             ? NULL 
                             : scm_to_locale_string(name),
                             (char *) "hinge",
                             rb_a->body,
                             rb_b->body);
  // XXX Add the update_function here.
  return smob;
}
<<file:rigid-body-smob.cpp>>=

SCM_DEFINE (scm_sim_add_constraint, "sim-add-constraint", 2, 0, 0,
            (SCM sim, SCM joint),
            "Add a constraint to the physics simulation.")
{
  extern btDynamicsWorld *world;
  struct constraint* c;

  struct sim *s = unwrap_sim(sim);

  scm_assert_smob_type(constraint_tag, joint);
  c = (struct constraint*) SCM_SMOB_DATA(joint);
  
  s->world->addConstraint(c->joint, true);
  c->world = s->world;
  return SCM_BOOL_T;
}
<<file:rigid-body-smob.cpp>>=

SCM_DEFINE (scm_sim_remove_constraint, "sim-remove-constraint", 2, 0, 0,
            (SCM sim, SCM joint),
            "Remove a constraint to the physics simulation.")
{
  extern btDynamicsWorld *world;
  struct constraint* c;

  struct sim *s = unwrap_sim(sim);

  scm_assert_smob_type(constraint_tag, joint);
  c = (struct constraint*) SCM_SMOB_DATA(joint);
  
  s->world->removeConstraint(c->joint);
  c->world = NULL;
  return SCM_BOOL_T;
}
@ \subsection{Actuate Joint}

<<file:rigid-body-smob.cpp>>=

SCM_DEFINE (actuate_joint, "actuate-joint", 2, 2, 0,
            (SCM joint_smob, SCM target_angle, SCM dt, SCM max_impulse),
            "Actuate a joint.")
{
  struct constraint *constraint;
  btHingeConstraint* hinge;
  scm_assert_smob_type(constraint_tag, joint_smob);
  constraint = (struct constraint*) SCM_SMOB_DATA(joint_smob);

  if (constraint->joint->getConstraintType() != HINGE_CONSTRAINT_TYPE) 
    return SCM_BOOL_F;
  hinge = (btHingeConstraint*) constraint->joint;
  constraint->bodyA->forceActivationState(ACTIVE_TAG);
  constraint->bodyB->forceActivationState(ACTIVE_TAG);
  if (scm_is_bool(target_angle)) {
    hinge->enableMotor(scm_is_true(target_angle) ? true : false);
  } else {
    hinge->enableMotor(true);
    hinge->setMaxMotorImpulse(SCM_UNBNDP(max_impulse) 
                              ? 1. : scm_to_double(max_impulse));
    hinge->setMotorTarget(scm_to_double(target_angle), 
                          SCM_UNBNDP(dt)
                          ? DEFAULT_TIME_STEP : scm_to_double(dt));
  }
  return SCM_BOOL_T;
}
@ We need the initialization to come last because of the SNARFing.

<<file:rigid-body-smob.cpp>>=

<<Initialize.>>
@ 
