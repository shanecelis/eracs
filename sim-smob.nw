\subsection{Simulation SMOB}

<<file:sim-smob.h>>=

#ifndef SCM_MAGIC_SNARFER
#include <btBulletDynamicsCommon.h>
#endif
#include <libguile.h>

struct sim {
  btDynamicsWorld *world;
  double elapsed_time;
};

SCM wrap_sim(btDynamicsWorld* world);

void init_sim_type(void);
struct sim* unwrap_sim(SCM sim_smob);
<<file:sim-smob.cpp>>=

<<+ Preamble>>

<<Includes>>
<<State>>

<<Helper Functions>>
<<Primitives>>

/* SMOB functions */
<<Free>>
<<Mark>>
<<Print>>
<<Includes>>=

#include "sim-smob.h"
<<Free>>=

static size_t free_sim (SCM sim_smob)
{
  struct sim *sim = (struct sim *) SCM_SMOB_DATA (sim_smob);
  if (sim->world)
    delete sim->world;
  scm_gc_free (sim, sizeof (struct sim), "sim");
  return 0;
}
<<Mark>>=

static SCM mark_sim (SCM sim_smob)
{
  //fprintf(stderr, "mark_sim\n");
  /* Mark the sim's name and update function.  */
  struct sim *sim = (struct sim *) SCM_SMOB_DATA (sim_smob);
     
  //scm_gc_mark (sim->name);
  //return (sim->contact_func); // will recurse and mark these
     
  return SCM_BOOL_F;
}
<<Print>>=

static int print_sim (SCM sim_smob, SCM port, scm_print_state *pstate)
{
  struct sim *sim = (struct sim *) SCM_SMOB_DATA (sim_smob);
     
  scm_puts ("#<sim ", port);
  scm_display (scm_from_double(sim->elapsed_time), port);
  scm_puts (">", port);
     
  /* Non-zero means success. */
  return 1;
}
@ XXX No longer static so it can be observed in
\verb|rigid-body-smob.cpp|.  Not sure I like this.

<<State>>=

static scm_t_bits sim_tag;
<<Initialize.>>=

void init_sim_type(void)
{
#ifndef SCM_MAGIC_SNARFER 
#include "sim-smob.cpp.x" 
#endif
  sim_tag = scm_make_smob_type ("sim", sizeof (struct sim));
  scm_set_smob_mark (sim_tag, mark_sim);
  scm_set_smob_free (sim_tag, free_sim);
  scm_set_smob_print (sim_tag, print_sim);
}
<<file:sim-smob.cpp>>=

SCM wrap_sim(btDynamicsWorld* btdw)
{
  SCM smob;
  static int sim_count = 0;
  struct sim *s;
     
  /* Step 1: Allocate the memory block.
   */
  s = (struct sim *)
    scm_gc_malloc (sizeof (struct sim), "sim");
     
  /* Step 2: Initialize it with straight code.
   */
  s->world = btdw;
  /* Step 3: Create the smob.
   */
  SCM_NEWSMOB (smob, sim_tag, s);
  s->world->setWorldUserInfo(smob);
  return smob;  
}
<<file:sim-smob.cpp>>=

struct sim* unwrap_sim(SCM sim_smob)
{
  scm_assert_smob_type(sim_tag, sim_smob);
  return (struct sim*) SCM_SMOB_DATA(sim_smob);
}
@ %def unwrap_sim
@ Now let's allow ourselves to create this C object from Scheme.

<<Includes>>=

#include "physics.h"
<<file:sim-smob.cpp>>=

SCM_DEFINE (scm_make_sim, "make-sim", 0, 0, 0,
            (),
            "Make a physics simulation.")
{
  btDynamicsWorld* world;
        btBroadphaseInterface*  m_broadphase;
        btCollisionDispatcher*  m_dispatcher;
        btConstraintSolver*     m_solver;
        btDefaultCollisionConfiguration* m_collisionConfiguration;

        m_collisionConfiguration = new btDefaultCollisionConfiguration();
        m_dispatcher = new btCollisionDispatcher(m_collisionConfiguration);
        btVector3 worldAabbMin(-10000,-10000,-10000);
        btVector3 worldAabbMax(10000,10000,10000);
        m_broadphase = new btAxisSweep3 (worldAabbMin, worldAabbMax);
        m_solver = new btSequentialImpulseConstraintSolver;

        world = new btDiscreteDynamicsWorld(m_dispatcher,
                                      m_broadphase,
                                      m_solver,
                                      m_collisionConfiguration);

  return wrap_sim(world);
}
<<Primitives>>=

SCM_DEFINE (scm_sim_tick, "sim-tick", 1, 1, 0,
            (SCM sim, SCM time_step),
            "Simulate physics for one time step.")
{
  scm_assert_smob_type(sim_tag, sim);
  struct sim *s = (struct sim*) SCM_SMOB_DATA(sim);
  btScalar dt = SCM_UNBNDP(time_step) 
    ? DEFAULT_TIME_STEP 
    : scm_to_double(time_step);
  s->world->stepSimulation(dt);
  s->elapsed_time += dt;
  return scm_from_double(s->elapsed_time);
}
<<Primitives>>=

SCM_DEFINE (scm_sim_time, "sim-time", 1, 0, 0,
            (SCM sim),
            "Simulate physics for one time step.")
{
  scm_assert_smob_type(sim_tag, sim);
  struct sim *s = (struct sim*) SCM_SMOB_DATA(sim);
  return scm_from_double(s->elapsed_time);
}
@ Just a stop gap measure.

<<Primitives>>=

SCM_DEFINE (scm_sim_add_ground_plane, "sim-add-ground-plane", 1, 0, 0,
            (SCM sim),
            "Get the global physics simulator.")
{
  btCollisionShape* groundShape;
  btCollisionObject* fixedGround;
  struct sim *s;
  scm_assert_smob_type(sim_tag, sim);
  s = (struct sim*) SCM_SMOB_DATA(sim);

  groundShape = 
    new btBoxShape(btVector3(btScalar(200.),btScalar(10.),btScalar(200.)));
  groundShape->setUserPointer(NULL);
  btTransform groundTransform;
  groundTransform.setIdentity();
  groundTransform.setOrigin(btVector3(0,-10,0));

  fixedGround = new btCollisionObject();
  fixedGround->setCollisionShape(groundShape);
  fixedGround->setWorldTransform(groundTransform);
  s->world->addCollisionObject(fixedGround);
  return SCM_BOOL_T;
}
<<file:sim-smob.cpp>>=

<<Initialize.>>
<<+ Include submodules.>>=

#include "sim-smob.h"
<<+ Initialize submodules.>>=

init_sim_type();
@
