% -*- mode: Noweb; noweb-code-mode: c-mode -*-
\section{Rendering}

Now we want to actually implement the rendering.  This will mainly
make use of the VL library.

<<file:render.h>>=
#include "scene-smob.h"

void render_init(int w, int h);
void render_setup_viewport(int w, int h);
void render_scene(struct scene*);
void render();
void render_update_camera(void);
extern struct scene* gscene;
<<file:render.cpp>>=

<<+ Preamble>>
#include "render.h"
#include "dummy-opengl-context.hpp"
#include <libguile.h>
<<Includes>>

<<State>>

<<Functions>>
@ 
We have a global scene struct named [[gscene]].

<<State>>=
struct scene *gscene;
SCM scm_gscene;
@ 

<<Functions>>=
void render_setup_viewport(int screen_width, int screen_height)
{
  gscene->rendering->camera()->viewport()->setWidth(screen_width);
  gscene->rendering->camera()->viewport()->setHeight(screen_height - echo_area_height);
  gscene->rendering->camera()->viewport()->setY(echo_area_height);

  //vl::ref<vl::Rendering> renderer3 = gscene->main_rendering->subRenderings()[0];
  renderer3->camera()->viewport()->setWidth(screen_width);
  renderer3->camera()->viewport()->setHeight(echo_area_height);
  renderer3->camera()->viewport()->setX(0);
  renderer3->camera()->viewport()->setY(0);
}
<<Functions>>=

void render_init(int screen_width, int screen_height)
{
  vl::ref<vl::Effect> effect;
  /* gscene = new scene; //(struct scene*) malloc(sizeof(struct scene)); */
  /* gscene->main_rendering = new vl::RenderingTree(); */
  /* gscene->scene_manager = new vl::SceneManagerActorTree; */
  /* gscene->rendering = new vl::Rendering(); */
  /* vl::vec4 background_color(61.f/255.f, 110.f/255.f, 203/255.f, 1.f); */
  /* gscene->rendering->camera()->viewport()->setClearColor(background_color); */
  /* gscene->rendering->renderer()->setFramebuffer(glcontext->framebuffer()); */
  /* gscene->rendering->sceneManagers()->push_back(gscene->scene_manager.get()); */
  /* gscene->main_rendering->subRenderings()->push_back(gscene->rendering.get()); */
  /* /\* define the camera position and orientation *\/ */
  /* gscene->eye        = vl::vec3(0,10,10);  */
  /* gscene->center     = vl::vec3(0, 0, 0);    */
  /* gscene->up         = vl::vec3(0, 1, 0); */
  /* gscene->render_fps = 0.0; */
  /* render_update_camera(); */
  // Did reference fragment 'Setup cube.'
  <<Setup the SCM scene object.>>

  <<Setup echo area.>>

  <<Setup cursor.>>

  <<Setup modeline.>>

}
@ 

<<Setup the SCM scene object.>>=
  //scm_gscene = scm_wrap_scene(gscene);
  scm_gscene = scm_make_scene();
  gscene = unwrap_scene(scm_gscene);
  scm_c_define("gscene", scm_gscene);
  scm_permanent_object(scm_gscene);
@ 
<<Functions>>=
void render()
{
  render_scene(gscene);
}
void render_scene(struct scene* scene)
{ 
  <<Before render>>
  <<Calculate FPS.>>

  scene->main_rendering->render();  
}
<<Calculate FPS.>>=

static unsigned int frame_count = 0;
static double start_time = vl::Time::currentTime(); 
if (frame_count != 0) {
  double time = (vl::Time::currentTime() - start_time);
  scene->render_fps = (double) frame_count/time;
  if (time > 1.0) {
    frame_count = 0;
    start_time = vl::Time::currentTime(); 
  }
    
}
frame_count++;
<<file:render.cpp>>=
void render_update_camera() {
  vl::mat4 view_mat = vl::mat4::getLookAt(gscene->eye, gscene->center, gscene->up);
  gscene->rendering->camera()->setViewMatrix( view_mat );
}
@ %def render_update_camera
<<Setup cube.>>=

  vl::ref<vl::Transform> cubeTransform;
  vl::ref<vl::Geometry> cube;
  /* Initialize scene. */
  cubeTransform = new vl::Transform;
  gscene->rendering->transform()->addChild(cubeTransform.get());
  cube = vl::makeBox(vl::vec3(0,0,0), 10, 10, 10);
  cube->computeNormals();

  effect = new vl::Effect; 
  effect->shader()->enable(vl::EN_DEPTH_TEST);
  effect->shader()->setRenderState(new vl::Light, 0);
  effect->shader()->enable(vl::EN_LIGHTING);
  effect->shader()->enable(vl::EN_BLEND);
  vl::vec4 color = vl::crimson;
  color.a() = 0.5;
  effect->shader()->gocMaterial()->setDiffuse(color);

  gscene->scene_manager->tree()->addActor(cube.get(), 
                                  effect.get(), 
                                  cubeTransform.get());
@ \subsection{Render Message or Echo Area}

We want to display the message or echo area at the bottom left of the
window as Emacs would typically do.  We'll need to include the Emacsy
header file.

<<Includes>>=
#include <emacsy.h>
@ We'll keep the text as global state.

<<State>>=
  vl::ref<vl::Text> echo_area;
  const int echo_area_height = 20; /* XXX this should be dynamic with font size */
@ We will refresh the state from Emacsy with each render.

\todo{This echo_area should be handled more carefully.  It needs to
  deal with text that's too large (that can slow down the whole
  program), and it needs to resize the minibuffer window when
  necessary.}
<<Before render>>=
  echo_area->setText(vl::String(emacsy_message_or_echo_area()));
@ Setting up the echo area is a little complicated.

<<State>>=
vl::ref<vl::Rendering> renderer3;
@ \end{multicols}
<<Setup echo area.>>=
  vl::ref<vl::Font> font;
  font = vl::defFontManager()->acquireFont("/Library/Fonts/Andale Mono.ttf", 
                                           12);
  vl::ref<vl::SceneManagerActorTree> scene_manager_text;
  scene_manager_text = new vl::SceneManagerActorTree;  
  echo_area = new vl::Text;
  echo_area->setFont(font.get());
  echo_area->setKerningEnabled(true);
  echo_area->setText( L"line 1\nline2\nline3\nline4\n");
  echo_area->setMode(vl::Text2D);
  //echo_area->setTextAlignment( vl::TextAlignJustify );
  int alignment = vl::AlignTop | vl::AlignLeft;
  echo_area->setAlignment(alignment);
  echo_area->setViewportAlignment(alignment);
  //echo_area->setBorderEnabled(false);
  echo_area->setBackgroundEnabled(false);
  echo_area->setColor( vl::white );
  //echo_area->translate(-100.f, 0.f, 0.f);
  renderer3 = new vl::Rendering;
  renderer3->camera()->viewport()->setClearColor(vl::black);
  renderer3->sceneManagers()->push_back(scene_manager_text.get());
  renderer3->renderer()->setFramebuffer(glcontext->framebuffer());

  effect = new vl::Effect;
  effect->shader()->enable(vl::EN_BLEND);
  scene_manager_text->tree()->addActor( echo_area.get(), effect.get() );
  gscene->main_rendering->subRenderings()->push_back(renderer3.get());
@ \begin{multicols}{2}

<<State>>=
  vl::ref<vl::Text> cursor;
@ 
<<Setup cursor.>>=
  cursor = new vl::Text;
  cursor->setFont(font.get());
  cursor->setKerningEnabled(true);
  cursor->setText( L"|");
  cursor->setMode(vl::Text2D);
  alignment = vl::AlignTop | vl::AlignLeft;
  cursor->setAlignment(alignment);
  cursor->setViewportAlignment(alignment);
  cursor->setBackgroundEnabled(false);
  cursor->setColor(vl::white);
  cursor->translate(10.f, 0.f, 0.f);
  scene_manager_text->tree()->addActor(cursor.get(), 
                                       effect.get());
@ 
<<Before render>>=
  int point = emacsy_minibuffer_point();
  float font_width = 10.f;
  cursor->resetMatrix();
  if (point != -1) 
    cursor->translate(((float)point - 1.25f) * font_width, 0.f, 0.f);
  else
    cursor->translate(-100.f, 0.f, 0.f);
@ \subsection{Render Modeline}
Now let's setup the modeline.  

<<State>>=
  vl::ref<vl::Text> modeline;
@ 
<<Setup modeline.>>=

  modeline = new vl::Text;
  modeline->setFont(font.get());
  modeline->setKerningEnabled(true);
  modeline->setText(L"");
  modeline->setMode(vl::Text2D);
  modeline->setTextAlignment(vl::TextAlignJustify);
  alignment = vl::AlignBottom | vl::AlignLeft;
  modeline->setAlignment(alignment);
  modeline->setViewportAlignment(alignment);
  modeline->setBorderEnabled(true);
  modeline->setBackgroundEnabled(true);
  modeline->setColor(vl::white);
  vl::fvec4 bg = vl::gray;
  bg.a() = 0.3;
  modeline->setBackgroundColor(bg);
  vl::ref<vl::ActorTree> tree = new vl::ActorTree();
  tree->addActor(modeline.get(), 
                 effect.get());
  gscene->scene_manager->tree()->addChild(tree.get());
@ 
<<Before render>>=
  modeline->setText(vl::String(emacsy_mode_line()));
@ VL requires an OpenGLContext object.  I implement it extremely
minimally because I do not want to use VL's GUI abstraction layer. 

<<OpenGL Context>>=
#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define SCREEN_DEPTH 8

/* 
   DummyOpenGLContext implements the required abstract methods of
   OpenGLContext.  My use case is that I do not want to use VL's GUI
   wrappers.  I want to use VL for gscene->rendering only.
*/
class DummyOpenGLContext : public vl::OpenGLContext {
public: 
  DummyOpenGLContext();
  virtual void swapBuffers();
  virtual void makeCurrent();
  virtual void update();
};
@ %def DummyOpenGLContext
<<file:dummy-opengl-context.hpp>>=

#include <vlGraphics/OpenGLContext.hpp>
<<OpenGL Context>>
<<file:dummy-opengl-context.cpp>>=

#include "dummy-opengl-context.hpp"

DummyOpenGLContext::DummyOpenGLContext() 
  : OpenGLContext(SCREEN_WIDTH, SCREEN_HEIGHT) {
  initGLContext();
}
void DummyOpenGLContext::swapBuffers() { }
void DummyOpenGLContext::makeCurrent() { }
void DummyOpenGLContext::update() { }
<<Includes>>=
#include <vlCore/VisualizationLibrary.hpp>
#include <vlCore/Time.hpp>
#include <vlGraphics/Rendering.hpp>
#include <vlGraphics/RenderingTree.hpp>
#include <vlGraphics/SceneManagerActorTree.hpp>
#include <vlGraphics/Geometry.hpp>
#include <vlGraphics/OpenGLContext.hpp>
#include <vlGraphics/GeometryPrimitives.hpp>
#include <vlGraphics/Light.hpp>
#include <vlGraphics/Text.hpp>
#include <vlGraphics/FontManager.hpp>
@
\subsection{Scheme Primitives}

One should be able to manipulate rendered objects in Scheme.  I want
to keep this API small.  I don't want to even try to expose all the
functionality VL provides.  It's sufficient for my purposes to be able
to draw text and boxes.  Instead of making all the properties of these
like color, texture, and lighting configurable, I'm going to make
collections of properties available, so one would define the property
in C++ but select it in Scheme.


